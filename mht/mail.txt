C++ MHT code


Hi --

Here's part of my C++ implementation of the mht algorithm.  Hope the
comments are interesting.  (Note: I think that mht_group.c will be
the most interesting file.  In that file, GROUP::merge() and
GROUP::splitIfYouMust() might be the most interesting routines.)

mht.h ------------------------------------------------------------------------------

/*********************************************************************
 * FILE: mht.H                                                       *
 *                                                                   *
 * AUTHOR: Matthew Miller (mlm)                                      *
 *                                                                   *
 * HISTORY:                                                          *
 *   11 AUG 93 -- (mlm) commented                                    *
 *                                                                   *
 * CONTENTS:                                                         *
 *                                                                   *
 *   Base classes for fundamental multiple hypothesis tracking       *
 *   algorithm.                                                      *
 *                                                                   *
 *   The purpose of this package is to separate the problem of       *
 *   tracking a single target from the problem of tracking multiple  *
 *   targets.  The application which uses this package need only     *
 *   define the way that individual track trees grow.  The MHT       *
 *   package, then, prunes the trees in such a way that, in the end, *
 *   each measurement report is assigned to at most one track.       *
 *                                                                   *
 *   To make an application that employs the mht algorithm, you      *
 *   define one or more subclasses of the base classes REPORT,       *
 *   T_HYPO, and MHT.  Each of these classes has a set of virtual    *
 *   functions that should be defined by the application             *
 *   programmer for his or her specific application.                 *
 *                                                                   *
 *   The basic meanings of these three base classes are as follows:  *
 *                                                                   *
 *     REPORT subclasses contain descriptions of reported            *
 *       measurements (e.g. blips from radar, or edgels in an        *
 *       image).                                                     *
 *                                                                   *
 *     T_HYPO ("track hypothesis") subclasses are the nodes on the   *
 *       track trees.  Each node represents a possible               *
 *       interpretation of the measurements reported at a given      *
 *       time.  For example, one type of T_HYPO might represent the  *
 *       possibility that a given REPORT was a report of the present *
 *       target, and contain an estimate of the target's position.   *
 *       Another type might represent the possibility that the       *
 *       target dissappeared.  Etc.  A path through the track tree   *
 *       represents a sequence of events in the life of the target.  *
 *                                                                   *
 *     The MHT subclass (there's usually only one per program)       *
 *       manages the track trees and reports, and prunes each tree   *
 *       down to a single path.                                      *
 *                                                                   *
 *   The main loop of an application should call the scan() member   *
 *   function of an MHT object.  This function goes through the      *
 *   following steps:                                                *
 *                                                                   *
 *     1. Call the virtual function measureAndValidate(), which must *
 *        be provided by the application, to gather a list of        *
 *        REPORTs, start new track trees, and grow new leaves for    *
 *        all the existing track trees.                              *
 *                                                                   *
 *        For example, in a radar-tracking application,              *
 *        measureAndValidate() would gather the measurements from    *
 *        the radar, put them in REPORT structures, and then         *
 *        validate them to the leaves of the track trees.            *
 *                                                                   *
 *     2. Prune the track trees according to a variety of pruning    *
 *        strategies.                                                *
 *                                                                   *
 *     3. For each track tree,                                       *
 *          While the root has only one child (because of pruning),  *
 *            if the root's m_mustVerify member (see below) is 1     *
 *              call the root's virtual verify() routine             *
 *            if the root's m_endsTrack member (see below) is 1      *
 *              remove the track tree                                *
 *            else                                                   *
 *              remove the root from the tree, making it's only      *
 *              child into the new root                              *
 *                                                                   *
 *   The verify() routines called in step 3, which are members of    *
 *   T_HYPO objects, should be used to define the application's      *
 *   behavior when a target's state has been determined.  For        *
 *   example, it might display a symbol on the screen representing   *
 *   the target's location, or make a separate record for later      *
 *   use.                                                            *
 *                                                                   *
 *   Each of the base classes is described in detail below.          *
 *                                                                   *
 *                           REPORT                                  *
 *                                                                   *
 *   A REPORT contains a description of a reported measurement.      *
 *   The code in the MHT package doesn't need to know any of the     *
 *   details of a REPORT.                                            *
 *                                                                   *
 *   Note: the REPORT base class cannot be copied because it has a   *
 *   "links to" member, whos copy constructor just generates an      *
 *   error.  Descendants of REPORT should have copy constructors     *
 *   which simply initialize their REPORT base with the default      *
 *   (no argument) constructer.  For example:                        *
 *                                                                   *
 *      class FOO: public REPORT                                     *
 *      {                                                            *
 *          .                                                        *
 *          .                                                        *
 *          .                                                        *
 *                                                                   *
 *        public:                                                    *
 *                                                                   *
 *          FOO( const FOO &src ):                                   *
 *            REPORT(),                                              *
 *            ...                                                    *
 *          .                                                        *
 *          .                                                        *
 *          .                                                        *
 *      };                                                           *
 *                                                                   *
 *                           T_HYPO                                  *
 *                                                                   *
 *   There are three main application-specific functions of a        *
 *   T_HYPO:                                                         *
 *                                                                   *
 *     1. When the application makes a T_HYPO, it must assign it a   *
 *        log-likelihood.  This is usually done in the constructor.  *
 *                                                                   *
 *     2. In each iteration, the application must give children to   *
 *        each T_HYPO that is a leaf of a track tree.  This is done  *
 *        by the measureAndValidate() member of the MHT object,      *
 *        which calls member functions of the T_HYPO leaves.         *
 *                                                                   *
 *     3. When a T_HYPO has been determined to be true (becomes the  *
 *        root of its tree), the application has an opportunity to   *
 *        respond (e.g. by displaying something on the screen).      *
 *        This is done by the T_HYPO's verify() member.              *
 *                                                                   *
 *   The constructors for T_HYPO are protected (so that T_HYPO may   *
 *   only be used as a base class).  They are:                       *
 *                                                                   *
 *     T_HYPO()                                                      *
 *                                                                   *
 *       This makes a T_HYPO that is independent of any REPORT.  For *
 *       example, one representing the possibility that a target     *
 *       is still in existance but wasn't detected.                  *
 *                                                                   *
 *     T_HYPO( REPORT *report )                                      *
 *                                                                   *
 *       This makes a T_HYPO that is based on the given REPORT.  For *
 *       example, one representing the possibility that the reported *
 *       measurement resulted from this target.                      *
 *                                                                   *
 *   The following member functions for T_HYPO's are public:         *
 *                                                                   *
 *     void installChild( T_HYPO *c )                                *
 *                                                                   *
 *       Install c as a child of this T_HYPO on its tree.            *
 *                                                                   *
 *     int endsTrack()                                               *
 *                                                                   *
 *       Returns the value of m_endsTrack (see below).               *
 *                                                                   *
 *     int mustVerify()                                              *
 *                                                                   *
 *       Returns the value of m_mustVerify (see below).              *
 *                                                                   *
 *     int hasReport()                                               *
 *                                                                   *
 *       Returns 1 if the T_HYPO constructor was called with a       *
 *       REPORT for an argument, 0 if it was called with no          *
 *       arguments.                                                  *
 *                                                                   *
 *     double getLogLikelihood()                                     *
 *                                                                   *
 *       Returns the value of m_logLikelihood (see below).           *
 *                                                                   *
 *     T_TREE *getTree()                                             *
 *                                                                   *
 *       Returns a pointer to the track tree that the T_HYPO is on.  *
 *       This probably shouldn't be called by any application code.  *
 *       The T_TREE structure has no user-serviceable parts inside.  *
 *                                                                   *
 *     int getTrackStamp()                                           *
 *                                                                   *
 *       Returns an integer which uniquely identifies the track tree *
 *       that this T_HYPO is on.                                     *
 *                                                                   *
 *     int getGroupId()                                              *
 *                                                                   *
 *       Returns an integer which uniquely identifies the group that *
 *       this T_HYPO's track tree is in (see implementation notes    *
 *       below).                                                     *
 *                                                                   *
 *     int getTimeStamp()                                            *
 *                                                                   *
 *       Returns the number of calls that were made to MHT::scan()   *
 *       before this T_HYPO was born.                                *
 *                                                                   *
 *     REPORT *getReport()                                           *
 *                                                                   *
 *       Returns the report that this T_HYPO was constructed with.   *
 *       This can only be used if the T_HYPO was constructed with a  *
 *       report (i.e. only if hasReport() returns 1).                *
 *                                                                   *
 *   The following virtual functions should be defined by the        *
 *   application:                                                    *
 *                                                                   *
 *     virtual void verify()                                         *
 *                                                                   *
 *       Called when this T_HYPO has been determined to be true.     *
 *                                                                   *
 *       Important: the verify() function is ONLY called if          *
 *       m_mustVerify is set to 1.  If m_mustVerify is set to 0, it  *
 *       will NEVER be called for that T_HYPO.  (See below).         *
 *                                                                   *
 *   The following protected member fields of a T_HYPO subclass      *
 *   should be set by the constructor:                               *
 *                                                                   *
 *     char m_endsTrack                                              *
 *                                                                   *
 *       This is a flag which indicates whether the T_HYPO indicates *
 *       that the tree is no longer of use.  For example, a type of  *
 *       T_HYPO that represents a target dissappearing should set    *
 *       this flag to 1.                                             *
 *                                                                   *
 *       Note: a T_HYPO that has m_endsTrack set to 1 still needs to *
 *       grow new children in every iteration.  Make a dummy T_HYPO  *
 *       subclass for this, which just takes the likelihood of its   *
 *       parent.  The dummy T_HYPOs should have m_endsTrack = 1.     *
 *                                                                   *
 *     char m_mustVerify                                             *
 *                                                                   *
 *       This flag indicates whether the T_HYPO's verify() member    *
 *       function actually does something.                           *
 *                                                                   *
 *       Important: the verify() function is ONLY called if          *
 *       m_mustVerify is set to 1.  If m_mustVerify is set to 0, it  *
 *       will NEVER be called for that T_HYPO.                       *
 *                                                                   *
 *     double m_logLikelihood                                        *
 *                                                                   *
 *       This is the log of the likelihood that the path from the    *
 *       original root of the tree to this T_HYPO is the closest to  *
 *       the truth.                                                  *
 *                                                                   *
 *                               MHT                                 *
 *                                                                   *
 *   The constructor for the MHT base class is protected, so it can  *
 *   only be constructed from subclasses.  It takes arguments that   *
 *   define the amount of each type of pruning:                      *
 *                                                                   *
 *     MHT( int maxDepth, double minGHypoRatio, int maxGHypos )      *
 *                                                                   *
 *       maxDepth is used for N-scanback pruning.  It defines the    *
 *       maximum depth that a track tree can reach before it will    *
 *       be pruned down to a single choice from the root.  Once so   *
 *       pruned, at least one node will be verified and removed      *
 *       from the tree in step 3 of scan() (see above).              *
 *                                                                   *
 *       minGHypoRatio is used for ratio pruning.  It defines the    *
 *       minimum ratio between the likelihood of the worst           *
 *       group hypothesis to that of the best (worst/best). Any      *
 *       group hypothesis with a likelihood lower than               *
 *       minGHypoRatio*likelihood-of-best-group-hypothesis will      *
 *       be discarded.                                               *
 *                                                                   *
 *       maxGHypos is used for k-best pruning.  It defines the       *
 *       maximum number of group hypotheses that will ever be        *
 *       considered for one group.                                   *
 *                                                                   *
 *       (See IMPLEMENTATION NOTES, below, for a discussion of       *
 *       groups and group hypotheses)                                *
 *                                                                   *
 *   There are two protected members which provide information       *
 *   for the application's use.  THESE MUST NOT BE DIRECTLY ALTERED  *
 *   BY THE APPLICATION:                                             *
 *                                                                   *
 *     iDLIST_OF< REPORT > m_newReportList                           *
 *                                                                   *
 *       This is a doubly-linked list (see "list.H") of the          *
 *       REPORTS that have been installed since the end of the last  *
 *       call to scan().  (See installReport(), below.)              *
 *                                                                   *
 *     ptrDLIST_OF< T_HYPO > m_activeTHypoList                       *
 *                                                                   *
 *       This is a doubly-linked list (see "list.H") of all the      *
 *       T_HYPO's that are currently leaves of track trees.          *
 *                                                                   *
 *   The following member functions are protected:                   *
 *                                                                   *
 *     void installReport( REPORT *report )                          *
 *                                                                   *
 *       Hand a REPORT to the MHT object.  This will place the       *
 *       REPORT on m_newReportList, for use later on.                *
 *                                                                   *
 *       The MHT object will delete the REPORT when it's done with   *
 *       it (when all the T_HYPO's that refer to it have been either *
 *       pruned or verified).                                        *
 *                                                                   *
 *     void installTree( T_HYPO *rootNode, int timeOffset = 0 )      *
 *                                                                   *
 *       Start a new track tree.  rootNode is the root of the tree.  *
 *       timeOffset is an amount to add to the currentTime (the      *
 *       counter of the number of calls to scan(), see below) to     *
 *       make the time stamp of the root.  This can be useful if     *
 *       the track tree will begin with a depth greater than 1, and  *
 *       the leaves should have time stamps equal to the current     *
 *       time.  In that case, timeOffset should be a negative number *
 *       equal in magnitude to the depth of the tree.                *
 *                                                                   *
 *       Note: due to the implementation of trees (see "tree.H"), it *
 *       isn't kosher to give a T_HYPO children before it is placed  *
 *       in a tree.  Thus, the only way to start a track tree with   *
 *       more than one node in it is to                              *
 *                                                                   *
 *         1. Construct the root T_HYPO.                             *
 *         2. Call installTree(), making the T_HYPO the root of a    *
 *            tree.                                                  *
 *         3. Make the other T_HYPO's for the tree, and place them   *
 *            on it by calling the installChild() member of the      *
 *            appropriate nodes.                                     *
 *                                                                   *
 *   The following member functions are public:                      *
 *                                                                   *
 *     int isInUse()                                                 *
 *                                                                   *
 *       Returns 1 if there are still active track trees in the MHT. *
 *       0 if not.                                                   *
 *                                                                   *
 *     int getCurrentTime()                                          *
 *                                                                   *
 *       Returns a count of the number of calls that have been made  *
 *       to scan() since the MHT was created.                        *
 *                                                                   *
 *     int scan()                                                    *
 *                                                                   *
 *       See the beginning of these comments for a description.      *
 *                                                                   *
 *       The return value is either 1, if there are some active      *
 *       track trees, or 0 if there were no REPORTs for the scan and *
 *       all of the track trees have been removed.                   *
 *                                                                   *
 *   The following virtual function must be defined in the           *
 *   application:                                                    *
 *                                                                   *
 *     virtual void measureAndValidate()                             *
 *                                                                   *
 *       This should do two things.                                  *
 *                                                                   *
 *       First, it should gather all the measurements for one scan   *
 *       and use installReport() to put REPORTs for them onto        *
 *       m_newReportList.                                            *
 *                                                                   *
 *       Second, it should go through the T_HYPOs in                 *
 *       m_activeTHypoList, giving each of them one or more          *
 *       children.  It is essential that EVERY T_HYPO in the list    *
 *       is given at least one child -- even T_HYPOs whose           *
 *       m_endsTrack members are set to 1.                           *
 *                                                                   *
 * IMPLEMENTATION NOTES:                                             *
 *                                                                   *
 *   Everything of importance starts with MHT::scan().  The basic    *
 *   behavior of scan() is described above, but I'll go into a       *
 *   little more detail here, to explain what the various classes    *
 *   defined in this file are for.                                   *
 *                                                                   *
 *   After calling measureAndValidate(), scan() arranges the track   *
 *   trees into GROUPs.  Each GROUP is a list of trees that share    *
 *   measurements.  Trees in different GROUPs are completely         *
 *   independent of each other.                                      *
 *                                                                   *
 *   The GROUPs are constructed incrementally.  First, each new tree *
 *   is placed in a new GROUP by itself.  Then, any two GROUPs that  *
 *   contain trees that share measurements are merged.  Finally,     *
 *   every GROUP that can be divided up (because some of the trees   *
 *   in them are no longer sharing any measurements) are split.      *
 *                                                                   *
 *   In addition to a list of track trees, each GROUP has a list of  *
 *   G_HYPO's (group hypotheses).  Each G_HYPO is a list of leaf     *
 *   T_HYPO's, one from each of the trees in the group.              *
 *   The leaves in one G_HYPO are compatible with each other -- the  *
 *   paths from the roots of the trees to those leaves don't share   *
 *   any measurements.  Each G_HYPO has a likelihood, computed as    *
 *   the product of the likelihoods of the T_HYPO's it postulates.   *
 *                                                                   *
 *   Since the GROUPs are computed incrementally, their G_HYPOs can  *
 *   be carried over from the previous call to scan().  But, after   *
 *   measureAndValidate() is called, the G_HYPOs become obsolete;    *
 *   they no longer point to leaves of the trees, since all the      *
 *   nodes that were previously leaves have been given children by   *
 *   measureAndValidate().                                           *
 *                                                                   *
 *   For each GROUP, now, we generate a new set of G_HYPOs.  To do   *
 *   this, we start by constructing assignment problems from all the *
 *   old G_HYPOs.  Each assignment problem covers that possible ways *
 *   of assigning the new REPORTs to the T_HYPOs in the old G_HYPO.  *
 *   Each of these possible assignments corresponds to one of the    *
 *   children of the T_HYPO.  Then, an ASSIGNMENT_PQUEUE (see        *
 *   apqueue.H) is used to come up with solutions to these           *
 *   assignment problems in decreasing order of likelihood.  A new   *
 *   G_HYPO is made to represent each of these solutions.            *
 *                                                                   *
 *   As soon as the first new G_HYPO is made, N-scanback pruning is  *
 *   applied.  This goes through each of the trees in the group,     *
 *   and, if the tree's depth is greater than m_maxDepth, prunes     *
 *   away the children of the root that don't lead to a leaf in the  *
 *   G_HYPO.  The root, then, is left with only one child (since     *
 *   the G_HYPO contains only one leaf from each tree), and will be  *
 *   removed in step 3 of the basic scan() steps described under     *
 *   CONTENTS, above.                                                *
 *                                                                   *
 *   After N-scanback pruning has been applied, some of the old      *
 *   G_HYPOs are no longer valid, since the nodes that they use have *
 *   been pruned away.  These G_HYPOs, and their corresponding       *
 *   assignment problems, are deleted.                               *
 *                                                                   *
 *   Finally, the remaining new G_HYPOs are generated.  Generation   *
 *   of G_HYPOs terminates when either m_minGHypoRatio or            *
 *   m_maxGHypos is reached (see the description of the MHT          *
 *   constructor, above).                                            *
 *                                                                   *
 *   Any leaf that doesn't make it into a G_HYPO is now removed.     *
 *   Any internal node that no longer has any children (because they *
 *   were removed) is now removed.                                   *
 *                                                                   *
 * ----------------------------------------------------------------- *
 *                                                                   *
 *             Copyright (c) 1993, NEC Research Institute            *
 *                       All Rights Reserved.                        *
 *                                                                   *
 *   Permission to use, copy, and modify this software and its       *
 *   documentation is hereby granted only under the following terms  *
 *   and conditions.  Both the above copyright notice and this       *
 *   permission notice must appear in all copies of the software,    *
 *   derivative works or modified versions, and any portions         *
 *   thereof, and both notices must appear in supporting             *
 *   documentation.                                                  *
 *                                                                   *
 *   Correspondence should be directed to NEC at:                    *
 *                                                                   *
 *                     Ingemar J. Cox                                *
 *                                                                   *
 *                     NEC Research Institute                        *
 *                     4 Independence Way                            *
 *                     Princeton                                     *
 *                     NJ 08540                                      *
 *                                                                   *
 *                     phone:  609 951 2722                          *
 *                     fax:  609 951 2482                            *
 *                     email:  ingemar@research.nj.nec.com (Inet)    *
 *                                                                   *
 *********************************************************************/

#ifndef MHT_H
#define MHT_H

#include <math.h>

#include "except.h"
#include "list.h"
#include "tree.h"
#include "links.h"
#include "vector.h"
#include "mem.h"

#ifdef DECLARE_MHT
  #define GLOBAL
  #define INITVAL( v ) = (v)
#else
  #define GLOBAL extern
  #define INITVAL( v )
#endif

static const double DOUBLE_NOT_READY = -INFINITY;

/*-------------------------------------------------------------------*
 | Stuff declared in this file
 *-------------------------------------------------------------------*/

GLOBAL long G_numCallsToScan;
GLOBAL double G_timeSpentInScan;
GLOBAL double G_numCallsToPruneAndHypothesize;
GLOBAL double G_timeSpentInPruneAndHypothesize;
GLOBAL double G_timeSpentInApqueue;
GLOBAL long G_numApqueueProblems;
GLOBAL long G_totalApqueueProblemSizes;
GLOBAL long G_maxApqueueProblemSize;
GLOBAL double G_totalApqueueProblemCoverage;
GLOBAL double G_minApqueueProblemCoverage INITVAL( INFINITY );
GLOBAL double G_maxApqueueProblemCoverage;

class REPORT;
class T_HYPO;
class G_HYPO;
class T_TREE;
class GROUP;
class MHT;

/*-------------------------------------------------------------------*
 | REPORT -- base class for measurement reports
 *-------------------------------------------------------------------*/

class REPORT: public DLISTnode
{
  friend T_HYPO;
  friend G_HYPO;
  friend MHT;

  protected: MEMBERS_FOR_DLISTnode( REPORT )

  private:

    int m_rowNum;                    // row number used to represent
                                     //   this REPORT in assignment
                                     //   problems
    int m_groupId;                   // unique id of GROUP that contains
                                     //   trees which use this REPORT
                                     //   (once the GROUPs have been
                                     //   merged and split properly,
                                     //   only one GROUP will contain
                                     //   trees referring to any given
                                     //   REPORT)
    LINKS_TO< T_HYPO > m_tHypoLinks; // links to T_HYPOs that use this
                                     //   REPORT

  public:

    REPORT():
      DLISTnode(),
      m_rowNum( 0 ),
      m_groupId( 0 ),
      m_tHypoLinks()
    {
    }

    virtual ~REPORT() {}

    void setGroupId( int groupId ) { m_groupId = groupId; }
    void setAllGroupIds( int groupId );
    void checkGroupIds();
    int isInUse() { return ! m_tHypoLinks.isEmpty(); }

  private:

    void setRowNum( int rowNum ) { m_rowNum = rowNum; }
    int getRowNum() { return m_rowNum; }

  public:

    virtual void print() { cout << "R:" << (void *)this; }
    virtual void describe( int spaces = 0 );
};

/*-------------------------------------------------------------------*
 | T_HYPO -- base class for track hypotheses
 *-------------------------------------------------------------------*/

class T_HYPO: public TREEnode
{
  friend REPORT;
  friend G_HYPO;
  friend T_TREE;
  friend MHT;

  protected: MEMBERS_FOR_TREEnode( T_HYPO )

  private:

    T_TREE *m_tree;                  // tree that this T_HYPO is on
    int m_timeStamp;                 // number of calls to MHT::scan()
                                     //   before this T_HYPO was made
    LINKS_TO< REPORT > m_reportLink; // link to one REPORT
    LINKS_TO< G_HYPO > m_gHypoLinks; // links to the G_HYPOs that
                                     //   postulate this T_HYPO
    char m_flag;                     // used in splitting GROUPs

  protected:

    char m_endsTrack;
    char m_mustVerify;
    double m_logLikelihood;

  protected:

    T_HYPO():
      TREEnode(),
      m_tree( 0 ),
      m_timeStamp( 0 ),
      m_reportLink(),
      m_gHypoLinks(),
      m_flag( 0 ),
      m_logLikelihood( DOUBLE_NOT_READY ),
      m_endsTrack( 0 ),
      m_mustVerify( 0 )
    {
    }

    T_HYPO( REPORT *report ):
      TREEnode(),
      m_tree( 0 ),
      m_timeStamp( 0 ),
      m_reportLink(),
      m_gHypoLinks(),
      m_flag( 0 ),
      m_logLikelihood( DOUBLE_NOT_READY ),
      m_endsTrack( 0 ),
      m_mustVerify( 0 )
    {
      BGN

      MAKE_LINK( this, m_reportLink,
                 report, m_tHypoLinks );
    }

    virtual ~T_HYPO() {}

  public:

    void installChild( T_HYPO *child )
    {
      BGN

      PTR_INTO_iTREE_OF< T_HYPO > p = this;

      p.insertFirstChild( child );
      child->setStamps( m_tree, m_timeStamp + 1 );
    }

    int endsTrack() { return m_endsTrack; }
    int mustVerify() { return m_mustVerify; }
    int hasReport() { return m_reportLink.hasOneMember(); }

    double getLogLikelihood()
    {
      #ifdef TSTBUG
        if( m_logLikelihood == DOUBLE_NOT_READY )
          THROW_ERR( "THypo wasn't given a logLikelihood" );
      #endif

      return m_logLikelihood;
    }

    T_TREE *getTree() { return m_tree; }

    inline int getTrackStamp();
    inline int getGroupId();

    int getTimeStamp() { return m_timeStamp; }
    REPORT *getReport() { return m_reportLink.getHead(); }

    virtual void verify()
      { THROW_ERR( "Call to T_HYPO::verify()" ) }

  private:

    int isInUse() { return ! isLeaf() || ! m_gHypoLinks.isEmpty(); }

    int getRowNum()
      { return hasReport() ? getReport()->getRowNum() : -1; }
    int getNumChildren()
      { return TREEnode::getNumChildren(); }

    void setStamps( T_TREE *tree, int timeStamp )
      { m_tree = tree; m_timeStamp = timeStamp; }

    void setFlag() { m_flag = 1; }
    void resetFlag() { m_flag = 0; }
    int flagIsSet() { return m_flag; }

  public:

    virtual void print() { cout << "T:" << (void *)this; }
    virtual void describe( int spaces = 0, int depth = 0 );
    virtual void describeTree( int spaces = 0, int depth = 0 );
};

/*-------------------------------------------------------------------*
 | G_HYPO -- group hypothesis
 *-------------------------------------------------------------------*/

class G_HYPO: public DLISTnode
{
  friend REPORT;
  friend T_HYPO;
  friend GROUP;
  friend MHT;

  protected: MEMBERS_FOR_DLISTnode( G_HYPO )

  private:

    double m_logLikelihood;          // log of likelihood
    int m_numTHyposUsedInProblem;    // this is the length of the
                                     //   m_tHypoLinks list at the time
                                     //   that an assignment problem is
                                     //   made for this G_HYPO.  If
                                     //   N-scanback pruning removes any
                                     //   T_HYPO that this G_HYPO
                                     //   postulates, it will also be
                                     //   automatically removed from
                                     //   m_tHypoLinks (see links.H).
                                     //   So we can tell that N-scanback
                                     //   pruning made the G_HYPO
                                     //   invalid by checking to see if
                                     //   m_numTHyposUsedInProblem is
                                     //   more than the length of
                                     //   m_tHypoLinks
    LINKS_TO< T_HYPO > m_tHypoLinks; // links to T_HYPOs postulated

  public:

    G_HYPO():
      DLISTnode(),
      m_logLikelihood( 0. ),
      m_numTHyposUsedInProblem( 0 ),
      m_tHypoLinks()
    {
    }

    G_HYPO( VECTOR_OF< void * > &solution, int solutionSize );

    int isInUse() { return ! m_tHypoLinks.isEmpty(); }

    double getLogLikelihood() const { return m_logLikelihood; }
    int wasReduced()
      { return m_numTHyposUsedInProblem > m_tHypoLinks.getLength(); }

    void setNumtHypos()
    {
        m_numTHyposUsedInProblem = m_tHypoLinks.getLength();
     }

    void addTHypo( T_HYPO *tHypo )
    {
      BGN

      m_logLikelihood += tHypo->getLogLikelihood();

      MAKE_LINK( this, m_tHypoLinks,
                 tHypo, m_gHypoLinks );
    }

    int getGroupId() { return (*m_tHypoLinks).getGroupId(); }
    int getNumTHypos() { return m_tHypoLinks.getLength(); }
    double getLogLikelihood() { return m_logLikelihood; }

    void makeProblem();
    void nScanBackPrune( int maxDepth );
    void recomputeLogLikelihood();

    int mustSplit();
    G_HYPO *split( int groupId );
    void merge( G_HYPO *src );

    void setFlags();
    void resetFlags();
    int allFlagsAreSet();

  public:

    virtual void print() { cout << "G:" << (void *)this; }
    virtual void describe( int spaces = 0 );
};

/*-------------------------------------------------------------------*
 | T_TREE -- track tree
 *-------------------------------------------------------------------*/

class T_TREE: public DLISTnode
{
  friend MHT;

  protected: MEMBERS_FOR_DLISTnode( T_TREE )

  private:

    iTREE_OF< T_HYPO > m_tree;
    int m_id;
    int m_groupId;

  private:

    T_TREE( T_HYPO *root, int id, int time ):
      DLISTnode(),
      m_tree(),
      m_id( id ),
      m_groupId( 0 )
    {
      m_tree.insertRoot( root );
      root->setStamps( this, time );
    }

  public:

    iTREE_OF< T_HYPO > *getTree() { return &m_tree; }
    int getId() { return m_id; }
    int getGroupId() { return m_groupId; }
    void setGroupId( int groupId ) { m_groupId = groupId; }
};

/*-------------------------------------------------------------------*
 | GROUP -- group of trees that share measurements
 *-------------------------------------------------------------------*/

class GROUP: public DLISTnode
{
  protected: MEMBERS_FOR_DLISTnode( GROUP )

  private:

    iDLIST_OF< G_HYPO > m_gHypoList;
    G_HYPO *m_bestGHypo;

    /* NOTE: the actual list of trees is implicit in the list of
       G_HYPOs, since each G_HYPO postulates one T_HYPO from each
       tree in the GROUP.  To find the trees in this group (which I
       never actually have to do), go through the m_tHypoLinks
       member of one of the G_HYPOs, and call the getTree() function
       for each T_HYPO on it. */

  public:

    GROUP(): DLISTnode(), m_gHypoList() {}

    GROUP( T_TREE *tree ):
      DLISTnode(),
      m_gHypoList()
    {
      m_gHypoList.append( new G_HYPO() );
      (*m_gHypoList).addTHypo( tree->getTree()->getRoot() );
    }

    int isInUse()
      { return ! m_gHypoList.isEmpty() && (*m_gHypoList).isInUse(); }

    void merge( GROUP *src,
                double logMinGHypoRatio,
                int maxGHypos );
    void splitIfYouMust();
    void removeRepeats();
    void clear(int depth);
    void pruneAndHypothesize( int maxDepth,
                              double logMinGHypoRatio,
                              int maxGHypos );

    int getGroupId() { return (*m_gHypoList).getGroupId(); }
    int getNumGHypos() { return m_gHypoList.getLength(); }

    void check();
    virtual void print() { cout << "C:" << (void *)this; }
    virtual void describe( int spaces = 0 );
};

/*-------------------------------------------------------------------*
 | MHT -- multiple hypothesis tracker
 *-------------------------------------------------------------------*/

class MHT
{
  private:

    int m_dbgEndA;
    int m_dbgStartB;
    int m_dbgEndB;
    int m_dbgStartC;
    int m_dbgEndC;

  protected:

    int m_lastTrackIdUsed;
    int m_currentTime;

    int m_maxDepth;
    double m_logMinGHypoRatio;
    int m_maxGHypos;

    iDLIST_OF< T_TREE > m_tTreeList;
    PTR_INTO_iDLIST_OF< T_TREE > m_nextNewTTree;
    iDLIST_OF< GROUP > m_groupList;
    iDLIST_OF< REPORT > m_oldReportList;

    int m_dbgStartA;
    iDLIST_OF< REPORT > m_newReportList;
    ptrDLIST_OF< T_HYPO > m_activeTHypoList;

  protected:

    MHT( int maxDepth, double minGHypoRatio, int maxGHypos ):
      m_lastTrackIdUsed( 0 ),
      m_currentTime( 0 ),
      m_maxDepth( maxDepth ),
      m_logMinGHypoRatio( log( minGHypoRatio ) ),
      m_maxGHypos( maxGHypos ),
      m_tTreeList(),
      m_nextNewTTree( m_tTreeList ),
      m_groupList(),
      m_oldReportList(),
      m_newReportList(),
      m_activeTHypoList(),
      m_dbgStartA( 0x7FFFFFFF ),
      m_dbgEndA( 0x7FFFFFFF ),
      m_dbgStartB( 0x7FFFFFFF ),
      m_dbgEndB( 0x7FFFFFFF ),
      m_dbgStartC( 0x7FFFFFFF ),
      m_dbgEndC( 0x7FFFFFFF )
    {
    }

    virtual ~MHT() {}

    void installReport( REPORT *report )
      { m_newReportList.append( report ); }

    void installTree( T_HYPO *rootNode, int timeOffset = 0 )
    {
      BGN

      T_TREE *tree = new T_TREE( rootNode,
                                 m_lastTrackIdUsed++,
                                 m_currentTime + timeOffset );

      m_activeTHypoList.append( *rootNode );
      m_tTreeList.append( tree );
      if( ! m_nextNewTTree.isValid() )
        m_nextNewTTree.set( m_tTreeList, START_AT_TAIL );
    }

  protected:

    virtual void measureAndValidate()
      { THROW_ERR( "Call to MHT::measureAndValidate()" ) }

  public:

    int isInUse() { return ! m_tTreeList.isEmpty(); }
    int getCurrentTime() { return m_currentTime; }

    int scan();
    void clear();

  private:

    void importNewReports();

    void makeNewGroups();
    void findGroupLabels();
    void splitGroups();
    void mergeGroups();

    void pruneAndHypothesize();
    void removeUnusedTHypos();
    void verifyTTreeRoots();
    void verifyLastTTreeRoots();

    void removeUnusedTTrees();
    void removeUnusedReports();
    void removeUnusedGroups();

    void updateActiveTHypoList();

    void checkGroups();
    void doDbgA();
    void doDbgB();
    void doDbgC();

  public:

    virtual void print() { cout << "M:" << (void *)this; }
    virtual void describe( int spaces = 0 );

    virtual void printStats( int spaces = 0 );

    void setDbgA( int start = 0x7FFFFFFF, int end = 0x7FFFFFFF )
      { m_dbgStartA = start; m_dbgEndA = end; }
    void setDbgB( int start = 0x7FFFFFFF, int end = 0x7FFFFFFF )
      { m_dbgStartB = start; m_dbgEndB = end; }
    void setDbgC( int start = 0x7FFFFFFF, int end = 0x7FFFFFFF )
      { m_dbgStartC = start; m_dbgEndC = end; }
};

/*-------------------------------------------------------------------*
 | Inline member functions that can't be written inside the class
 | definitions because they refer to stuff declared later that the
 | classes they come from (results of chicken-and-egg problems).
 *-------------------------------------------------------------------*/

inline int T_HYPO::getTrackStamp()
{
  #ifdef TSTBUG
    if( m_tree == 0 )
      THROW_ERR( "Trying to get track stamp from "
                 "uninitialized tHypo" )
  #endif

  return m_tree->getId();
}

inline int T_HYPO::getGroupId()
{
  #ifdef TSTBUG
    if( m_tree == 0 )
      THROW_ERR( "Trying to get group id from "
                 "uninitialized tHypo" )
  #endif

  return m_tree->getGroupId();
}

#endif

mht.c ------------------------------------------------------------------------------

/*********************************************************************
 * FILE: mht.C                                                       *
 *                                                                   *
 * AUTHOR: Matthew Miller (mlm)                                      *
 *                                                                   *
 * HISTORY:                                                          *
 *   12 AUG 93 -- (mlm) commented                                    *
 *                                                                   *
 * CONTENTS:                                                         *
 *                                                                   *
 *   Member functions for MHT objects.  See mht.H for details.       *
 *                                                                   *
 * ----------------------------------------------------------------- *
 *                                                                   *
 *             Copyright (c) 1993, NEC Research Institute            *
 *                       All Rights Reserved.                        *
 *                                                                   *
 *   Permission to use, copy, and modify this software and its       *
 *   documentation is hereby granted only under the following terms  *
 *   and conditions.  Both the above copyright notice and this       *
 *   permission notice must appear in all copies of the software,    *
 *   derivative works or modified versions, and any portions         *
 *   thereof, and both notices must appear in supporting             *
 *   documentation.                                                  *
 *                                                                   *
 *   Correspondence should be directed to NEC at:                    *
 *                                                                   *
 *                     Ingemar J. Cox                                *
 *                                                                   *
 *                     NEC Research Institute                        *
 *                     4 Independence Way                            *
 *                     Princeton                                     *
 *                     NJ 08540                                      *
 *                                                                   *
 *                     phone:  609 951 2722                          *
 *                     fax:  609 951 2482                            *
 *                     email:  ingemar@research.nj.nec.com (Inet)    *
 *                                                                   *
 *********************************************************************/

#define DECLARE_MHT

#include <stdio.h>

#include "mht.h"
#include "timer.h"

/*-------------------------------------------------------------------*
 | MHT::scan() -- do an iteration of the mht algorithm
 *-------------------------------------------------------------------*/

int MHT::scan()
{
  BGN

  Timer timer;

  G_numCallsToScan++;

  measureAndValidate();
  m_currentTime++;

  if( m_dbgStartA <= m_currentTime && m_currentTime < m_dbgEndA )
    doDbgA();

  m_activeTHypoList.removeAll();
  importNewReports();

  if( m_tTreeList.isEmpty() )
  {
    G_timeSpentInScan += timer.elapsedTime();
    return 0;
  }

  makeNewGroups();
  findGroupLabels();
  splitGroups();
  mergeGroups();

  if( m_dbgStartB <= m_currentTime && m_currentTime < m_dbgEndB )
    doDbgB();

  pruneAndHypothesize();
  removeUnusedTHypos();
  verifyTTreeRoots();

  removeUnusedTTrees();
  removeUnusedReports();
  removeUnusedGroups();

  updateActiveTHypoList();

  if( m_dbgStartC <= m_currentTime && m_currentTime < m_dbgEndC )
    doDbgC();

  G_timeSpentInScan += timer.elapsedTime();

  return 1;
}

/*-------------------------------------------------------------------*
 | MHT::importNewReports() -- set up to deal with new REPORTs
 |
 | This assigns a row number to each new REPORT, for use in making
 | assignment problems later on, and moves all the REPORTs from the
 | new report list to the old report list.
 *-------------------------------------------------------------------*/

void MHT::importNewReports()
{
  BGN

  PTR_INTO_iDLIST_OF< REPORT > reportPtr;
  int rowNum;

  rowNum = 0;
  LOOP_DLIST( reportPtr, m_newReportList )
  {
    (*reportPtr).setRowNum( rowNum++ );
  }

  m_oldReportList.splice( m_newReportList );
}

/*-------------------------------------------------------------------*
 | MHT::makeNewGroups() -- make a new GROUP for each new track tree
 *-------------------------------------------------------------------*/

void MHT::makeNewGroups()
{
  BGN

  for( ; m_nextNewTTree.isValid(); ++m_nextNewTTree )
  {
    m_groupList.append( new GROUP( m_nextNewTTree.get() ) );
  }
}

/*-------------------------------------------------------------------*
 | MHT::findGroupLabels() -- label track trees and REPORTs for
 |                           grouping
 |
 | This is the first step in splitting and merging GROUPs.  Here, we
 | find out which GROUP each T_TREE and REPORT should be in.  The
 | algorithm for doing this is derived from the one described in
 |
 |   T. Kurien
 |   Issues in the Design of Practical Multitarget Tracking
 |   Algorithms
 |   in Yaakov Bar-Shalom, Ed.
 |   Multitarget-Multisensor Tracking
 |
 | My (derived) algorithm proceeds in three steps:
 |
 | 1. All the T_TREE groupId members are initialized to -1, which   
 |    indicates they haven't been grouped yet.
 |
 | 2. We loop through the list of all the old REPORTs, assigning each
 |    a group id by means of the member function setAllGroupIds().
 |    This function also gives the group id to all the T_TREEs that
 |    refer to the REPORT.  If a T_TREE has already been given a
 |    group id by a previous REPORT, then that report is also given
 |    the new id.
 |
 | 3. After step 2, all the T_TREEs that refer to any REPORT have
 |    been given group id's.  But there might be a few T_TREEs that
 |    don't refer to any REPORTs at all.  The last step is to give
 |    each of these T_TREEs a unique group id (since each of them can
 |    be in a GROUP by itself).
 *-------------------------------------------------------------------*/

void MHT::findGroupLabels()
{
  BGN

  PTR_INTO_iDLIST_OF< T_TREE > tTreePtr;
  PTR_INTO_iDLIST_OF< REPORT > reportPtr;
  int groupId;

  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    (*tTreePtr).setGroupId( -1 );
  }

  groupId = 1;

  LOOP_DLIST( reportPtr, m_oldReportList )
  {
    (*reportPtr).setAllGroupIds( groupId++ );
  }

  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    if( (*tTreePtr).getGroupId() == -1 )
      (*tTreePtr).setGroupId( groupId++ );
  }

  #ifdef TSTBUG
    if( ! m_newReportList.isEmpty() )
      THROW_ERR( "m_newReportList must be empty in findGroupLabels()" )
  #endif

  #ifdef DEBUG
    LOOP_DLIST( reportPtr, m_oldReportList )
    {
      (*reportPtr).checkGroupIds();
    }
  #endif
}

/*-------------------------------------------------------------------*
 | MHT::splitGroups() -- split GROUPs that can split
 |
 | The hard part of this is handled in GROUP::splitIfYouMust().
 *-------------------------------------------------------------------*/

void MHT::splitGroups()
{
  BGN

  PTR_INTO_iDLIST_OF< GROUP > groupPtr;

  LOOP_DLIST( groupPtr, m_groupList )
  {
    (*groupPtr).splitIfYouMust();
  }
}

/*-------------------------------------------------------------------*
 | MHT::mergeGroups() -- merge GROUPs that must merge
 |
 | Two GROUPs must merge if they both contain T_TREEs with the same
 | group id.  This routine simply goes through the list of GROUPs
 | from head to tail, and, for each GROUP, searches the rest of the
 | list for a GROUP with the same group id.  When it finds one, it
 | merges the two GROUPs, removes the one it found, and continues
 | searching.
 *-------------------------------------------------------------------*/

void MHT::mergeGroups()
{
  BGN

  PTR_INTO_iDLIST_OF< GROUP > groupPtr0;
  PTR_INTO_iDLIST_OF< GROUP > groupPtr1;
  int groupId;

  LOOP_DLIST( groupPtr0, m_groupList )
  {
    groupId = (*groupPtr0).getGroupId();

    for( groupPtr1 = groupPtr0, ++groupPtr1;
         groupPtr1.isValid();
         ++groupPtr1 )
      if( (*groupPtr1).getGroupId() == groupId )
      {
        (*groupPtr0).merge( groupPtr1.get(),
                            m_logMinGHypoRatio,
                            m_maxGHypos );
        groupPtr1.remove();
      }
  }
}

/*-------------------------------------------------------------------*
 | MHT::pruneAndHypothesize() -- prune track trees and create new
 |                               G_HYPOs for each GROUP
 *-------------------------------------------------------------------*/

void MHT::pruneAndHypothesize()
{
  BGN

  PTR_INTO_iDLIST_OF< GROUP > groupPtr;

  LOOP_DLIST( groupPtr, m_groupList )
  {
    (*groupPtr).pruneAndHypothesize( m_maxDepth,
                                     m_logMinGHypoRatio,
                                     m_maxGHypos );
  }
}

void MHT::clear()
{
  BGN

  PTR_INTO_iDLIST_OF< GROUP > groupPtr;
  for (int i=m_maxDepth; i>=0; i--) 
  {
    LOOP_DLIST( groupPtr, m_groupList )
    {
      (*groupPtr).clear( i);
    }
    verifyTTreeRoots();
    removeUnusedTTrees();
    removeUnusedReports();
    removeUnusedGroups();
  }
  verifyLastTTreeRoots();
}

/*-------------------------------------------------------------------*
 | MHT::removeUnusedTHypos() -- remove the T_HYPOs that are not
 |                              referred to in any G_HYPO, or have
 |                              had all their children removed
 *-------------------------------------------------------------------*/

void MHT::removeUnusedTHypos()
{
  BGN

  PTR_INTO_iDLIST_OF< T_TREE > tTreePtr;
  PTR_INTO_iTREE_OF< T_HYPO > tHypoPtr;

  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    LOOP_TREEpostOrder( tHypoPtr, *(*tTreePtr).getTree() )
    {
      if( ! (*tHypoPtr).isInUse() )
        tHypoPtr.removeSubtree();
    }
  }
}

/*-------------------------------------------------------------------*
 | MHT::verifyTTreeRoots() -- verify and remove track tree roots that
 |                            have only one child
 *-------------------------------------------------------------------*/

void MHT::verifyTTreeRoots()
{
  BGN

  PTR_INTO_iDLIST_OF< T_TREE > tTreePtr;
  iTREE_OF< T_HYPO > *tTree;
  T_HYPO *root;

  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    tTree = (*tTreePtr).getTree();

    if( ! tTree->isEmpty() )
    {
      root = tTree->getRoot();
      while( root->hasOneChild() && ! root->endsTrack() )
      {
        if( root->mustVerify() )
          root->verify();
        tTree->removeRoot();

        root = tTree->getRoot();
      }

      if( root->endsTrack() && root->mustVerify() )
        root->verify();
    }
  }
}

void MHT::verifyLastTTreeRoots()
{
  BGN

  PTR_INTO_iDLIST_OF< T_TREE > tTreePtr;
  iTREE_OF< T_HYPO > *tTree;
  T_HYPO *root;

  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    tTree = (*tTreePtr).getTree();

    if( ! tTree->isEmpty() )
    {
      root = tTree->getRoot();
      if( root)
      {
        if( root->mustVerify() )
          root->verify();
        tTree->removeRoot();
      }

    }
  }
}

/*-------------------------------------------------------------------*
 | MHT::removeUnusedTTrees() -- remove track trees that aren't needed
 |
 | A track tree should be removed if either of the following is true:
 |
 | 1. It's root node ends the tree (since the root node has been
 |    identified as true, so the tree is done).
 |
 | 2. All possible paths from the root lead to nodes that end the
 |    tree, and contain no nodes that must be verified (basically,
 |    the tree isn't really done yet, but the application doesn't
 |    care what happens with it, so it can be discarded).
 *-------------------------------------------------------------------*/

void MHT::removeUnusedTTrees()
{
  BGN

  PTR_INTO_iDLIST_OF< T_TREE > tTreePtr;
  iTREE_OF< T_HYPO > *tTree;
  PTR_INTO_iTREE_OF< T_HYPO > tHypoPtr;
  int treeIsInUse;

  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    tTree = (*tTreePtr).getTree();
    treeIsInUse = 0;

    if( ! tTree->isEmpty() &&
        ! tTree->getRoot()->endsTrack() )
      LOOP_TREE( tHypoPtr, *tTree )
      {
        if( (*tHypoPtr).mustVerify() ||
            (tHypoPtr.isAtLeaf() && ! (*tHypoPtr).endsTrack()) )
        {
          treeIsInUse = 1;
          break;
        }
      }

    if( ! treeIsInUse )
      tTreePtr.remove();
  }
}

/*-------------------------------------------------------------------*
 | MHT::removeUnusedReports() -- remove REPORTs that aren't used by
 |                               any T_HYPOs
 *-------------------------------------------------------------------*/

void MHT::removeUnusedReports()
{
  BGN

  PTR_INTO_iDLIST_OF< REPORT > reportPtr;

  LOOP_DLIST( reportPtr, m_oldReportList )
    if( ! (*reportPtr).isInUse() )
      reportPtr.remove();
}

/*-------------------------------------------------------------------*
 | MHT::removeUnusedGroups() -- remove GROUPs that have no track
 |                              trees left in them
 *-------------------------------------------------------------------*/

void MHT::removeUnusedGroups()
{
  BGN

  PTR_INTO_iDLIST_OF< GROUP > groupPtr;

  LOOP_DLIST( groupPtr, m_groupList )
    if( ! (*groupPtr).isInUse() )
      groupPtr.remove();
}

/*-------------------------------------------------------------------*
 | MHT::updateActiveTHypoList() -- build the list of T_HYPOs that are
 |                                 leaves of track trees
 *-------------------------------------------------------------------*/

void MHT::updateActiveTHypoList()
{
  BGN

  PTR_INTO_iDLIST_OF< T_TREE > tTreePtr;
  PTR_INTO_iTREE_OF< T_HYPO > tHypoPtr;

  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    LOOP_TREE( tHypoPtr, *(*tTreePtr).getTree() )
    {
      if( tHypoPtr.isAtLeaf() )
        m_activeTHypoList.append( *tHypoPtr );
    }
  }
}

/*-------------------------------------------------------------------*
 | MHT::checkGroups() -- test that groups are correct (for debugging)
 *-------------------------------------------------------------------*/

void MHT::checkGroups()
{
  BGN

  PTR_INTO_iDLIST_OF< GROUP > groupPtr0;
  PTR_INTO_iDLIST_OF< GROUP > groupPtr1;
  int groupId;

  LOOP_DLIST( groupPtr0, m_groupList )
  {
    (*groupPtr0).check();
  }

  LOOP_DLIST( groupPtr0, m_groupList )
  {
    groupId = (*groupPtr0).getGroupId();

    for( (groupPtr1 = groupPtr0),++groupPtr1; groupPtr1.isValid(); ++groupPtr1)
      if( (*groupPtr1).getGroupId() == groupId )
        THROW_ERR( "Two groups with same id" )
  }
}

/*-------------------------------------------------------------------*
 | MHT::describe() -- verbose diagnostic
 *-------------------------------------------------------------------*/

void MHT::describe( int spaces )
{
  BGN

  PTR_INTO_ptrDLIST_OF< T_HYPO > tHypoPtr;
  PTR_INTO_iDLIST_OF< GROUP > groupPtr;
  PTR_INTO_iDLIST_OF< REPORT > reportPtr;
  PTR_INTO_iDLIST_OF< T_TREE > tTreePtr;
  int k;

  Indent( spaces ); cout << "MHT "; print(); cout << endl;
  spaces += 2;

  Indent( spaces );
  cout << "lastTrackUsed = " << m_lastTrackIdUsed;
  cout << ", time = " << m_currentTime;
  cout << endl;

  Indent( spaces );
  cout << "maxDepth = " << m_maxDepth;
  cout << ", logMinRatio = " << m_logMinGHypoRatio;
  cout << ", maxGHypos = " << m_maxGHypos;
  cout << endl;

  Indent( spaces ); cout << "active tHypo's:";
  k = 0;

  LOOP_DLIST( tHypoPtr, m_activeTHypoList )
  {
    if( k++ >= 3 )
    {
      cout << endl;
      Indent( spaces ); cout << "               ";
      k = 0;
    }

    cout << " "; (*tHypoPtr).print();
  }
  cout << endl;

  Indent( spaces ); cout << "===== clusters"; cout << endl;
  LOOP_DLIST( groupPtr, m_groupList )
  {
    (*groupPtr).describe( spaces + 2 );
  }

  Indent( spaces ); cout << "===== oldReports"; cout << endl;
  LOOP_DLIST( reportPtr, m_oldReportList )
  {
    (*reportPtr).describe( spaces + 2 );
  }

  Indent( spaces ); cout << "===== newReports"; cout << endl;
  LOOP_DLIST( reportPtr, m_newReportList )
  {
    (*reportPtr).describe( spaces + 2 );
  }

  Indent( spaces ); cout << "===== oldTrees"; cout << endl;
  LOOP_DLIST( tTreePtr, m_tTreeList )
  {
    if( tTreePtr == m_nextNewTTree )
    {
      Indent( spaces ); cout << "===== newTrees"; cout << endl;
    }

    cout << endl;
    (**(*tTreePtr).getTree()).describeTree( spaces + 2 );
  }
}

/*-------------------------------------------------------------------*
 | MHT::printStats() -- print out some information about the progress
 |                      of the mht
 *-------------------------------------------------------------------*/

void MHT::printStats( int spaces )
{
  BGN

  int totalTTrees = m_tTreeList.getLength();
  int totalTHypos = m_activeTHypoList.getLength();
  int totalGroups = m_groupList.getLength();
  int totalGHypos;
  int maxGHypos;
  int numGHypos;
  PTR_INTO_iDLIST_OF< GROUP > groupPtr;

  totalGHypos = 0;
  maxGHypos = 0;
  LOOP_DLIST( groupPtr, m_groupList )
  {
    numGHypos = (*groupPtr).getNumGHypos();

    totalGHypos += numGHypos;
    if( maxGHypos < numGHypos )
      maxGHypos = numGHypos;
  }

  Indent( spaces ); cout << "track trees ---------------- "
                         << totalTTrees << endl;
  Indent( spaces ); cout << "  track hypos:          "
                         << totalTHypos << endl;
  Indent( spaces ); cout << "  hypos per tree:       "
                         << (double)totalTHypos / totalTTrees << endl;
  Indent( spaces ); cout << "groups --------------------- "
                         << totalGroups << endl;
  Indent( spaces ); cout << "  group hypos:          "
                         << totalGHypos << endl;
  Indent( spaces ); cout << "  hypos per group:      "
                         << (double)totalGHypos / totalGroups << endl;
  Indent( spaces ); cout << "  max hypos in a group: "
                         << maxGHypos << endl;
}

/*-------------------------------------------------------------------*
 | Debugging routines
 *-------------------------------------------------------------------*/

void MHT::doDbgA()
{
  BGN

  cout << endl;
  cout << "  ************************** MHT after measureAndValidate()"
       << endl;

  describe( 4 );

  cout << "  HIT RETURN..." << endl;
  getchar();
}

void MHT::doDbgB()
{
  BGN

  cout << endl;
  cout << "  ******************************* MHT after group formation"
       << endl;

  describe( 4 );

  cout << "  HIT RETURN..." << endl;
  getchar();
}

void MHT::doDbgC()
{
  BGN

  cout << endl;
  cout << "  *************************************** MHT after pruning"
       << endl;

  describe( 4 );

  cout << "  HIT RETURN..." << endl;
  getchar();
}

mht_group.c ------------------------------------------------------------------------

/*********************************************************************
 * FILE: mht_group.C                                                 *
 *                                                                   *
 * AUTHOR: Matthew Miller (mlm)                                      *
 *                                                                   *
 * HISTORY:                                                          *
 *   12 AUG 93 -- (mlm) commented                                    *
 *                                                                   *
 * CONTENTS:                                                         *
 *                                                                   *
 *   Member functions for GROUP and G_HYPO objects.  See mht.H.      *
 *                                                                   *
 * ----------------------------------------------------------------- *
 *                                                                   *
 *             Copyright (c) 1993, NEC Research Institute            *
 *                       All Rights Reserved.                        *
 *                                                                   *
 *   Permission to use, copy, and modify this software and its       *
 *   documentation is hereby granted only under the following terms  *
 *   and conditions.  Both the above copyright notice and this       *
 *   permission notice must appear in all copies of the software,    *
 *   derivative works or modified versions, and any portions         *
 *   thereof, and both notices must appear in supporting             *
 *   documentation.                                                  *
 *                                                                   *
 *   Correspondence should be directed to NEC at:                    *
 *                                                                   *
 *                     Ingemar J. Cox                                *
 *                                                                   *
 *                     NEC Research Institute                        *
 *                     4 Independence Way                            *
 *                     Princeton                                     *
 *                     NJ 08540                                      *
 *                                                                   *
 *                     phone:  609 951 2722                          *
 *                     fax:  609 951 2482                            *
 *                     email:  ingemar@research.nj.nec.com (Inet)    *
 *                                                                   *
 *********************************************************************/

#include <stdlib.h>

#include "mht.h"
#include "apqueue.h"
#include "pqueue.h"
#include "timer.h"

/*-------------------------------------------------------------------*
 | g_apqueue -- assignment priority queue for generating new G_HYPOs
 *-------------------------------------------------------------------*/

static ASSIGNMENT_PQUEUE g_apqueue;

/*-------------------------------------------------------------------*
 | Stuff used by GROUP::merge()
 |
 | Merge is more complicated than it might seem.
 |
 | Here's the way a simple algorithm would work:
 |
 |   For each G_HYPO, A, in GROUP 0
 |     For each G_HYPO, B, in GROUP 1
 |       Make a new G_HYPO that consists of the list of T_HYPOs from
 |       A concatenated with the T_HYPOs from B.  The likelihood of
 |       This new G_HYPO is just the product of the likelihood of A
 |       and the likelihood of B.
 |
 | The problem with this is that it can produce too many new G_HYPOs.
 |
 | To ensure that we never have a GROUP that violates the pruning
 | parameters, we have to generate the new G_HYPOs in decreasing order
 | of likelihood, stopping when either the likelihood ratio has gone
 | below m_minGHypoRatio or the total number of G_HYPOs has reached
 | m_maxGHypos.
 |
 | Here's the algorithm I use:
 |
 | 1. Make a list of the G_HYPOs in GROUP 0, sorted in decreasing
 |    order of likelihood
 |
 | 2. Make a list of the G_HYPOs in GROUP 1, sorted in decreasing
 |    order of likelihood
 |
 | 3. Initialize a priority queue (see pqueue.H) with a "G_HYPO_PAIR"
 |    structure, which contains two indices, one into each of the
 |    two arrays of pointers to G_HYPOs.  This initial G_HYPO_PAIR
 |    has both indices set to 0.
 |
 |    A G_HYPO_PAIR indicates two G_HYPOs that can be combined to
 |    make a new G_HYPO for the merged GROUP.  Since the two lists
 |    are sorted by likelihood, and the likelihood of the resulting
 |    G_HYPO will be the product of the likelihoods of the two
 |    G_HYPOs indicated, the initial G_HYPO_PAIR indicates the most
 |    likely pair.
 |
 | 4. While the priority queue is not empty, the likelihood ratio
 |    hasn't gone below m_minGHypoRatio, and the total number of new
 |    G_HYPOs made hasn't reached m_maxGHypos
 |
 |    4.1 Get the next G_HYPO_PAIR off the priority queue.  This will
 |        indicate the most likely G_HYPO remaining to be made.
 |
 |    4.2 Make the G_HYPO that the G_HYPO_PAIR indicates.
 |
 |        Now, the next-most-likely G_HYPO after this one will be
 |        made by keeping one of the two G_HYPOs we just combined,
 |        and replacing the other with its successor in the array
 |        that it came from.  So ...
 |
 |    4.3 If the G_HYPO_PAIR's index into array 0 (from GROUP 0)
 |        is less than the number of elements in array 0,
 |        4.3.1 Make a new G_HYPO_PAIR, in which the index for array
 |              0 is incremented by 1, and put it on the priority
 |              queue
 |    4.4 If the G_HYPO_PAIR's index into array 1 (from GROUP 1)
 |        is less than the number of elements in array 1,
 |        4.4.1 Make a new G_HYPO_PAIR, in which the index for array
 |              1 is incremented by 1, and put it on the priority
 |              queue
 |
 | To reduce the number of G_HYPO_PAIRs put onto the priority queue,
 | and prevent the same pair from being generated more than once,
 | I use an array of flags to say whether a given pair has been used
 | or not.  The array has one flag for each possible pair.  The flag
 | is set to 1 as soon as the corresponding pair has been placed on
 | the priority queue.  If the flag is already 1, the pair is not
 | placed on the queue again.
 *-------------------------------------------------------------------*/

/* g_gHypoArray0 and g_gHypoArray1 are the two arrays of pointers to
   G_HYPOs being combined for GROUP::merge().

   NOTE: The compiler I'm using has a problem with globals
   that are referred to by objects that are placed in container
   classes.  Since G_HYPO_PAIR refers to g_gHypoArray0 and
   g_gHypoArray1, and G_HYPO_PAIR is used in the PQUEUE_OF<> container
   class, the problem happens here.  The symptoms are:

   1. If the global is declared static, then two separate instances
      of it are allocated -- one that can be accessed by G_HYPO_PAIR,
      and one that can be accessed by the rest of the program.

   2. If the global is not static, then its constructor and destructor
      are both called twice.

   I've worked around this by using SAFE_GLOBAL().  See safeglobal.H.
*/

#ifdef COMPILER_IS_DEBUGGED
  static VECTOR_OF< G_HYPO * > g_gHypoArray0;
  static VECTOR_OF< G_HYPO * > g_gHypoArray1;
#else
  #define GLOBAL
  SAFE_GLOBAL( VECTOR_OF< G_HYPO * >, g_gHypoArray0 )
  SAFE_GLOBAL( VECTOR_OF< G_HYPO * >, g_gHypoArray1 )
  #undef GLOBAL
#endif
#define KBEST
#define NSCAN_BACK_PRUNING

/* flags for pairs of G_HYPOs */
static VECTOR_OF< char > g_gHypoPairUsed;

/* structure indicating a pair of G_HYPOs */
struct G_HYPO_PAIR
{
  int i0, i1;

  G_HYPO_PAIR(): i0( 0 ), i1( 0 ) {}

  G_HYPO_PAIR( int i0Arg, int i1Arg ):
    i0( i0Arg ),
    i1( i1Arg )
  {
  }

  G_HYPO *getGHypo0() const { BGN return g_gHypoArray0[ i0 ]; }
  G_HYPO *getGHypo1() const { BGN return g_gHypoArray1[ i1 ]; }

  double getLogLikelihood() const
  {
    return getGHypo0()->getLogLikelihood() +
           getGHypo1()->getLogLikelihood();
  }

  int operator<( const G_HYPO_PAIR &that ) const
  {
    return getLogLikelihood() < that.getLogLikelihood();
  }

  int operator>( const G_HYPO_PAIR &that ) const
  {
    return getLogLikelihood() > that.getLogLikelihood();
  }
};

/*-------------------------------------------------------------------*
 | setupArray0() and setupArray1() -- routines to fill in
 |                                    g_gHypoArray0 and g_gHypoArray1
 |
 | These routines perform steps 1 and 2 of the algorithm described
 | above.
 |
 | NOTE: compareGHypoPtrs(), which I'd really rather put after the
 | two setupArray routines, has to go first because of some weirdness
 | with the way the SGI compiler handles templates.
 *-------------------------------------------------------------------*/

static int compareGHypoPtrs( const void *addr0, const void *addr1 )
{
  BGN

  #define gHypo0 (*(G_HYPO **)addr0)
  #define gHypo1 (*(G_HYPO **)addr1)

  if( gHypo0->getLogLikelihood() < gHypo1->getLogLikelihood() )
    return 1;
  if( gHypo0->getLogLikelihood() > gHypo1->getLogLikelihood() )
    return -1;
  return 0;

  #undef gHypo0
  #undef gHypo1
}

static void setupArray0( iDLIST_OF< G_HYPO > &gHypoList, int numGHypos )
{
  BGN

  int compareGHypoPtrs( const void *addr0, const void *addr1 );

  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;
  int i;

  g_gHypoArray0.resize( numGHypos );

  i = 0;
  LOOP_DLIST( gHypoPtr, gHypoList )
  {
    (*gHypoPtr).recomputeLogLikelihood(); // make sure logLikelihood
                                          //   is up to date
    g_gHypoArray0[ i++ ] = gHypoPtr.get();
  }

  qsort( &g_gHypoArray0[ 0 ],
         numGHypos,
         sizeof( G_HYPO * ),
         compareGHypoPtrs );
}

static void setupArray1( iDLIST_OF< G_HYPO > &gHypoList, int numGHypos )
{
  BGN

  int compareGHypoPtrs( const void *addr0, const void *addr1 );

  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;
  int i;

  g_gHypoArray1.resize( numGHypos );

  i = 0;
  LOOP_DLIST( gHypoPtr, gHypoList )
  {
    (*gHypoPtr).recomputeLogLikelihood(); // make sure logLikelihood
                                          //   is up to date
    g_gHypoArray1[ i++ ] = gHypoPtr.get();
  }

  qsort( &g_gHypoArray1[ 0 ],
         numGHypos,
         sizeof( G_HYPO * ),
         compareGHypoPtrs );
}

/*-------------------------------------------------------------------*
 | GROUP::merge() -- merge two GROUPs
 |
 | See above for algorithm.
 *-------------------------------------------------------------------*/

void GROUP::merge( GROUP *src,
                   double logMinGHypoRatio,
                   int maxGHypos )
{
  BGN

  #define G_HYPO_PAIR_USED( g0, g1 ) \
    g_gHypoPairUsed[ ((g0) * maxGHypos) + g1 ]

  static PQUEUE_OF< G_HYPO_PAIR > pqueue;
  G_HYPO_PAIR gHypoPair( 0, 0 );
  G_HYPO *gHypo;
  double bestLogLikelihood;
  int numGHypos0;
  int numGHypos1;
  iDLIST_OF< G_HYPO > newGHypoList;
  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;
  int i;

  numGHypos1 = src->m_gHypoList.getLength();
  numGHypos0 = m_gHypoList.getLength();
  CheckMem();

  if( numGHypos1 == 1 )
  {

    LOOP_DLIST( gHypoPtr, m_gHypoList )
    {
      (*gHypoPtr).merge( src->m_gHypoList.getHead() );
       CheckMem();
    }
    src->m_gHypoList.removeAll();

    return;
  }
  setupArray0( m_gHypoList, numGHypos0 );
  setupArray1( src->m_gHypoList, numGHypos1 );
  pqueue.clear();
  pqueue.resize( 2 * maxGHypos );
  g_gHypoPairUsed.resize( 0, maxGHypos * maxGHypos );
  g_gHypoPairUsed.clear();
  bestLogLikelihood = gHypoPair.getLogLikelihood();
  i = 0;
  while( i < maxGHypos &&
         gHypoPair.getLogLikelihood() - bestLogLikelihood >=
           logMinGHypoRatio )
  {
    gHypo = new G_HYPO;
    gHypo->merge( gHypoPair.getGHypo0() );
    gHypo->merge( gHypoPair.getGHypo1() );
    newGHypoList.append( gHypo );
    CheckMem();
    if( gHypoPair.i0 + 1 < numGHypos0 &&
        ! G_HYPO_PAIR_USED( gHypoPair.i0 + 1, gHypoPair.i1 ) )
    {
      pqueue.put( G_HYPO_PAIR( gHypoPair.i0 + 1, gHypoPair.i1 ) );
      G_HYPO_PAIR_USED( gHypoPair.i0 + 1, gHypoPair.i1 ) = 1;
    }
    if( gHypoPair.i1 + 1 < numGHypos1 &&
        ! G_HYPO_PAIR_USED( gHypoPair.i0, gHypoPair.i1 + 1 ) )
    {
      pqueue.put( G_HYPO_PAIR( gHypoPair.i0, gHypoPair.i1 + 1 ) );
      G_HYPO_PAIR_USED( gHypoPair.i0, gHypoPair.i1 + 1 ) = 1;
    }
    if( ! pqueue.isEmpty() )
      gHypoPair = pqueue.get();
    else
      break;

    i++;
  }

/* 
  LOOP_LINKS( gHypoPtr, m_gHypoList )
  {
    (*gHypoPtr).describe( 2 );
  }
*/

  m_gHypoList.removeAll();
  CheckMem();

  src->m_gHypoList.removeAll();
  CheckMem();
  m_gHypoList.splice( newGHypoList );

  #undef G_HYPO_PAIR_USED
}

/*-------------------------------------------------------------------*
 | GROUP::splitIfYouMust() -- split the GROUP into two parts if it
 |                            needs to be split
 |
 | A GROUP can be split if it contains trees that have been assigned
 | different group id's.  This routine checks to see if that's true,
 | and splits the GROUP in two if it is.
 |
 | When the GROUP is split, it keeps all the trees with one group id,
 | and gives all the other trees to the new GROUP, which is placed
 | onto the list of GROUPs directly after this one.  In other words,
 | if we have a list of GROUPs
 |
 |   A B C D
 |
 | and GROUP B is split, then the list will contain
 |
 |   A B B1 C D
 |
 | where B and B1 are the two GROUPs resulting from the split.
 |
 | All the trees in the new B have the same group id.  The trees in
 | B1 might have different group id's, so splitIfYouMust() should be
 | called for B1 next.  This happens automatically if splitIfYouMust()
 | is being called in a loop:
 |
 |   LOOP_DLIST( groupPtr, m_groupList )
 |   {
 |     (*groupPtr).splitIfYouMust();
 |   }
 |
 | When groupPtr points to B, B is split into the new B and B1.
 | groupPtr still points to B, so in the next iteration of the loop
 | it will be moved to B's successor, which is now B1, and
 | splitIfYouMust() will be called for B1.
 |
 | The splitting itself simply requires splitting each G_HYPO
 | according to the group id that is to be kept in this GROUP.  This
 | is accomplished by G_HYPO::split(), which keeps all the trees
 | that have the given group id, and puts all the others into a new
 | G_HYPO, which it returns.
 |
 | Once the GROUP has been split, some G_HYPOs might end up identical
 | (since the only difference between them, originally, was in the
 | T_HYPO they chose for a tree that's no longer in the GROUP).  These
 | are removed by removeRepeats().
 *-------------------------------------------------------------------*/

void GROUP::splitIfYouMust()
{
  BGN

  GROUP *newGroup;
  int groupId;
  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;

  if( m_gHypoList.isEmpty() || ! (*m_gHypoList).mustSplit() )
    return;

  newGroup = new GROUP();
  groupId = (*m_gHypoList).getGroupId();

  LOOP_DLIST( gHypoPtr, m_gHypoList )
  {
    newGroup->m_gHypoList.append( (*gHypoPtr).split( groupId ) );
  }

  removeRepeats();
  newGroup->removeRepeats();

  /* put the new group onto the list after this one */
  append( newGroup );
}

/*-------------------------------------------------------------------*
 | GROUP::removeRepeats() -- remove identical G_HYPOs from the GROUP
 |
 | Each G_HYPO in the list is compared with all the G_HYPOs that come
 | after it.  All the ones that are identical to it are removed.
 | This means there will be no identical pairs of G_HYPOs left after
 | the routine is done.
 |
 | Here's the algorithm:
 |
 | 1. For each G_HYPO, A, on the list
 |    1.1 Flag all the T_HYPOs that are referred to in A
 |    1.2 For each G_HYPO, B, on the list after A
 |        1.2.1 Check to see if all the T_HYPOs referred to in B
 |              have been flagged.  If they all have, then A and B
 |              refer to exactly the same T_HYPOs, and are identical,
 |              so ...
 |              1.2.1.1 Remove B
 |    1.3 Unflag all the T_HYPOs that are referred to in A
 *-------------------------------------------------------------------*/

void GROUP::removeRepeats()
{
  BGN

  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr0;
  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr1;

  LOOP_DLIST( gHypoPtr0, m_gHypoList )
  {
    (*gHypoPtr0).setFlags();

    for( gHypoPtr1 = gHypoPtr0, ++gHypoPtr1;
         gHypoPtr1.isValid();
         ++gHypoPtr1 )
      if( (*gHypoPtr1).allFlagsAreSet() )
        gHypoPtr1.remove();

    (*gHypoPtr0).resetFlags();
  }
}

/*-------------------------------------------------------------------*
 | GROUP::pruneAndHypothesize() -- prune the track trees and make new
 |                                 G_HYPOs
 |
 | The algorithm for this is described in mht.H.
 *-------------------------------------------------------------------*/

void GROUP::pruneAndHypothesize( int maxDepth,
                                 double logMinGHypoRatio,
                                 int maxGHypos )
{
  BGN

  Timer timer0;
  Timer timer1;
  G_numCallsToPruneAndHypothesize++;

  VECTOR_OF< void * > solution;
  int solutionSize;
  double bestCost;

  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;
  G_HYPO *newGHypo;

  iDLIST_OF< G_HYPO > newGHypoList;

  int numNewGHypos;

  /* make an assignment problem for each G_HYPO, and put it on an
     assignment priority queue (see apqueue.H) */

  g_apqueue.removeAllProblems();

  LOOP_DLIST( gHypoPtr, m_gHypoList )
  {
    (*gHypoPtr).makeProblem();
  }

  /* if there are no possible assignments, do nothing (this GROUP is
     empty */
  if( g_apqueue.isEmpty() )
  {
    G_timeSpentInPruneAndHypothesize += timer0.elapsedTime();
    return;
  }

  /* get the best solution to an assignment problem */

  timer1.reset_clock();
  bestCost = g_apqueue.getNextSolutionCost();
  g_apqueue.getNextSolution( solution, &solutionSize );


  /* make a new G_HYPO based on the solution to the assignment
     problem */
  
  m_bestGHypo = new G_HYPO( solution, solutionSize );
  
  newGHypoList.append( m_bestGHypo );
  numNewGHypos = 1;

  /* make the rest of the new G_HYPOs */
  while( numNewGHypos < maxGHypos &&
         ! g_apqueue.isEmpty() &&
         bestCost - g_apqueue.getNextSolutionCost() >=
           logMinGHypoRatio )
  {
    g_apqueue.getNextSolution( solution, &solutionSize );

    newGHypo = new G_HYPO( solution, solutionSize );
    newGHypoList.append( newGHypo );
    numNewGHypos++;
  }
  G_timeSpentInApqueue += timer1.elapsedTime();

  LOOP_DLIST( gHypoPtr, newGHypoList )
  {
     (*gHypoPtr).setNumtHypos();
  }

  /* apply N-scanback pruning, and remove any G_HYPO that loses a
     T_HYPO in the process */
  m_bestGHypo->nScanBackPrune( maxDepth );

  LOOP_DLIST( gHypoPtr, newGHypoList )
    if( (*gHypoPtr).wasReduced() )
    {
      g_apqueue.removeProblem( gHypoPtr );
      gHypoPtr.remove();
    }


  /* replace the old G_HYPOs with the new ones */
  m_gHypoList.removeAll();
  m_gHypoList.splice( newGHypoList );

  G_timeSpentInPruneAndHypothesize += timer0.elapsedTime();
}

void GROUP::clear( int maxDepth)
{
  BGN

  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;

  LOOP_DLIST( gHypoPtr, m_gHypoList )
     (*gHypoPtr).setNumtHypos();

  /* apply N-scanback pruning, and remove any G_HYPO that loses a
     T_HYPO in the process */
  m_bestGHypo->nScanBackPrune( maxDepth );

  LOOP_DLIST( gHypoPtr, m_gHypoList )
    if( (*gHypoPtr).wasReduced() )
    {
      g_apqueue.removeProblem( gHypoPtr );
      gHypoPtr.remove();
    }
}

/*-------------------------------------------------------------------*
 | GROUP::check() -- check that the group is ok (diagnostic tool)
 *-------------------------------------------------------------------*/

void GROUP::check()
{
  BGN

  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;
  int numTHypos;
  int groupId;

  numTHypos = (*m_gHypoList).getNumTHypos();
  if( numTHypos == 0 )
    THROW_ERR( "Group with 0 trees" )
  groupId = (*m_gHypoList).getGroupId();
  LOOP_DLIST( gHypoPtr, m_gHypoList )
  {
    if( (*gHypoPtr).getNumTHypos() != numTHypos )
      THROW_ERR( "Group with different numbers of tHypos" )
    if( (*gHypoPtr).getGroupId() != groupId )
      THROW_ERR( "More than one group id in same group" )
  }
}

/*-------------------------------------------------------------------*
 | GROUP::describe() -- diagnostic tool
 *-------------------------------------------------------------------*/

void GROUP::describe( int spaces )
{
  BGN

  PTR_INTO_iDLIST_OF< G_HYPO > gHypoPtr;

  Indent( spaces ); cout << "CLUSTER "; print(); cout << endl;

  LOOP_LINKS( gHypoPtr, m_gHypoList )
  {
    (*gHypoPtr).describe( spaces + 2 );
  }
}

/*-------------------------------------------------------------------*
 | G_HYPO::G_HYPO() -- constructor for making G_HYPOs based on
 |                     solutions to assignment problems
 |
 | See G_HYPO::makeProblem() for an explanation.
 *-------------------------------------------------------------------*/

G_HYPO::G_HYPO( VECTOR_OF< void * > &solution, int solutionSize ):
  m_logLikelihood( 0 ),
  m_numTHyposUsedInProblem( 0 ),
  m_tHypoLinks()
{
  BGN

  int i;
  for( i = 0; i < solutionSize; i++ )
    addTHypo( (T_HYPO *)solution[ i ] );
}

/*-------------------------------------------------------------------*
 | G_HYPO::makeProblem() -- make an assignment problem for a G_HYPO
 |
 | I think the best way to describe what's happening in this routine
 | is with an example and some diagrams.
 |
 |                      track tree 0         track tree 1
 |   +--------+              |                    |
 |   | G_HYPO |============--+------------------  |
 |   +--------+            \ |                  \ |
 |                         +---+                +---+
 |                         | A |                | B |
 |                         +---+                +---+
 |                         / | \                / | \
 |                        /  |  \              /  |  \
 |                   +---+ +---+ +---+    +---+ +---+ +---+
 |                   | C | | D | | E |    | F | | G | | H |
 |                   +---+ +---+ +---+    +---+ +---+ +---+
 |   +----------+    /      |             /      |
 |   | REPORT 0 |====-------+-------------       |
 |   +----------+           |                    |
 |                          |                    |
 |   +----------+          /                    /
 |   | REPORT 1 |==========---------------------
 |   +----------+
 |
 | A through H are T_HYPOs in two track trees (the whole track trees
 | aren't shown).  C, D, and E are new leaves of track tree 0.  F, G,
 | and H are new leaves of track tree 1.  A and B were leaves in the
 | previous iteration, before measureAndValidate() was called.
 |
 | C represents the possibility that REPORT 0 should be assigned to
 | track 0.  D represents the possibility that REPORT 1 should be
 | assigned to track 0.  E represents a way that no REPORT might be
 | assigned to track 0.  Similarly, F, G, and H represent the
 | possibilities that REPORT 0, REPORT 1, or no REPORT should be
 | assigned to track 1, respectively.
 |
 | The G_HYPO is old, left over from the previous scan when A and
 | B were leaves. It postulates that the true state of track 0 is the
 | one represented by A, and the true state of track 1 is the one
 | represented by B.  We're calling G_HYPO::makeProblem() as a step
 | in the construction of the new G_HYPOs that will be children of
 | this one.  Each of these children will postulate a legal combination
 | of one of C, D, or E, with one of F, G, or H.
 |
 | Since each REPORT may be assigned to only one track, and each
 | track may have no more than one REPORT assigned to it, what we
 | have here is a classical assignment problem (see apqueue.H and
 | assign.H).  Drawing the assignment problem as a bipartite graph,
 | we get:
 |
 |      "rows"              "columns"
 |
 |               unassigned
 |                    \
 |                     \E
 |   +----------+   C   \
 |   | REPORT 0 |-------- track tree 0
 |   +----------+       /
 |               \     /D
 |                \   /
 |                 \ /
 |                  X
 |                 / \
 |                /   \
 |               /     \F
 |   +----------+       \
 |   | REPORT 1 |-------- track tree 1
 |   +----------+   G   /
 |                     /H
 |                    /
 |               unassigned
 |
 | Each of the "row" nodes in the graph represents a report.  Each of
 | the "column" nodes represents a track tree.  Each of the arcs,
 | which specify possible assignments, corresponds to a leaf T_HYPO in
 | one of the trees.  The cost of an arc is the negated log
 | likelihood of the T_HYPO it corresponds to (negated because the
 | assignment code minimizes the cost, and we want to maximize the
 | likelihood).
 |
 | A solution to this problem is a list of arcs.  Since each arc
 | corresponds to a T_HYPO, this is the same as a list of T_HYPOs.
 | And a list of T_HYPOs is a G_HYPO.  The log likelihood of the
 | G_HYPO is just the negated cost of the solution.
 |
 | What makeProblem() does is to construct the assignment problem
 | for an old G_HYPO and put it on the ASSIGNMENT_PQUEUE.  The
 | tag fields of the ROW_COL_COST structures (see assign.H)
 | are set to point to the T_HYPOs that they correspond to.  So,
 | to make a G_HYPO from a solution to one of these problems, we
 | need only make a list of the T_HYPOs that the solution points to.
 |
 | The row and column numbers used in the problem are arbitrary.
 | But it is more memory efficient if their ranges are kept to a
 | minimum.  Each REPORT is assigned a unique row number when it is
 | imported by MHT::importNewReports().  Each track tree is given
 | a column number on the fly (just an integer that's incremented
 | through the loop).
 *-------------------------------------------------------------------*/

void G_HYPO::makeProblem()
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  PTR_INTO_iTREE_OF< T_HYPO > childPtr;
  VECTOR_OF< ROW_COL_COST > rcc;
  int numRCCs;
  int rccNum;
  int colNum;
  int maxRow;

  /* record the number of T_HYPOs in the G_HYPO (which is the same
     as the number of track trees), for use later in determining
     whether the G_HYPO has become invalid as a result of pruning */
  m_numTHyposUsedInProblem = m_tHypoLinks.getLength();

  /* count the number of ROW_COL_COST structures that there will be
     in the assignment problem */
  numRCCs = 0;
  maxRow = 0;
  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    #ifdef TSTBUG
      if( (*tHypoPtr).isLeaf() )
        THROW_ERR( "THypo has no children for next iteration" )
    #endif

    numRCCs += (*tHypoPtr).getNumChildren();
  }

  /* make room for the ROW_COL_COST structures */
  rcc.resize( numRCCs );

  /* make ROW_COL_COST structures out of the T_HYPOs */
  rccNum = 0;
  colNum = 0;
  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    LOOP_TREEchildren( childPtr, tHypoPtr.get() )
    {
      rcc[ rccNum++ ].set( (*childPtr).getRowNum(), colNum,
                           -(*childPtr).getLogLikelihood(),
                            childPtr.get() );
      if( (*childPtr).getRowNum() > maxRow )
        maxRow = (*childPtr).getRowNum();
    }
    colNum++;
  }

  /* sort the ROW_COL_COST structures and put the problem on the
     ASSIGNMENT_PQUEUE */
  SortAssignmentProblem( &rcc[ 0 ], numRCCs );
  g_apqueue.addProblem( this, &rcc[ 0 ], rccNum, maxRow + 1, colNum );

  G_numApqueueProblems++;
  G_totalApqueueProblemSizes += numRCCs;
  if( numRCCs > G_maxApqueueProblemSize )
    G_maxApqueueProblemSize = numRCCs;

  double problemCoverage = (double)numRCCs /
                           ((double)(maxRow + 2) * (colNum + 1) - 1.);

  G_totalApqueueProblemCoverage += problemCoverage;
  if( problemCoverage < G_minApqueueProblemCoverage )
    G_minApqueueProblemCoverage = problemCoverage;
  if( problemCoverage > G_maxApqueueProblemCoverage )
    G_maxApqueueProblemCoverage = problemCoverage;
}

/*-------------------------------------------------------------------*
 | G_HYPO::nScanBackPrune() -- perform N-scanback pruning
 |
 | This is called for the most likely G_HYPO in each group.  The
 | algorithm is:
 |
 |   For each T_HYPO in the G_HYPO
 |     Trace the path from the T_HYPO to the root of the track tree
 |     that it's on.
 |     If the length of that path is greater than maxDepth
 |       Find the node in the path that is a child of the root.
 |       Prune away all the other children of the root, along with
 |       their descendants.
 *-------------------------------------------------------------------*/

void G_HYPO::nScanBackPrune( int maxDepth )
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  PTR_INTO_iTREE_OF< T_HYPO > parentPtr;
  PTR_INTO_iTREE_OF< T_HYPO > siblingPtr;
  PTR_INTO_iTREE_OF< T_HYPO > tHypoToSave;
  int depth;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    if( (*tHypoPtr).isRoot() )
      continue;

    depth = 1;
    
    tHypoToSave = tHypoPtr.get();

    for( parentPtr = tHypoPtr.get(), parentPtr.gotoParent();
         ! parentPtr.isAtRoot();
         tHypoToSave = parentPtr, parentPtr.gotoParent() )
      depth++;
    if( depth < maxDepth )
      continue;
    
    LOOP_TREEchildren( siblingPtr, parentPtr )
      if( siblingPtr != tHypoToSave )
        siblingPtr.removeSubtree();
  }
}

/*-------------------------------------------------------------------*
 | G_HYPO::recomputeLogLikelihood() -- make sure the log likelihood
 |                                     of the G_HYPO is up to date
 *-------------------------------------------------------------------*/

void G_HYPO::recomputeLogLikelihood()
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;

  m_logLikelihood = 0;
  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    m_logLikelihood += (*tHypoPtr).getLogLikelihood();
  }
}

/*-------------------------------------------------------------------*
 | G_HYPO::mustSplit() -- determine if the G_HYPO should be split
 |
 | A G_HYPO should be split into G_HYPOs for different GROUPs if it
 | refers to track trees that have been assigned different group id's.
 *-------------------------------------------------------------------*/

int G_HYPO::mustSplit()
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  int groupId;

  if( m_tHypoLinks.isEmpty() )
    return 0;

  groupId = (*m_tHypoLinks).getGroupId();

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
    if( (*tHypoPtr).getGroupId() != groupId )
      return 1;
  return 0;
}

/*-------------------------------------------------------------------*
 | G_HYPO::split() -- split a G_HYPO in two
 |
 | The G_HYPO keeps all the track trees that have been assigned the
 | given group id, and puts all the others into a new G_HYPO, which
 | it returns.
 *-------------------------------------------------------------------*/

G_HYPO *G_HYPO::split( int groupId )
{
  BGN

  G_HYPO *newGHypo = new G_HYPO();
  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  T_HYPO *tHypo;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    tHypo = tHypoPtr.get();

    if( tHypo->getGroupId() != groupId )
    {
      tHypoPtr.remove();
      m_logLikelihood -= tHypo->getLogLikelihood();
      newGHypo->addTHypo( tHypo );
    }
  }

  return newGHypo;
}

/*-------------------------------------------------------------------*
 | G_HYPO::merge() -- merge the G_HYPO with another G_HYPO
 *-------------------------------------------------------------------*/

void G_HYPO::merge( G_HYPO *src )
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;

  LOOP_LINKS( tHypoPtr, src->m_tHypoLinks )
  {
    addTHypo( tHypoPtr.get() );
  }
}

/*-------------------------------------------------------------------*
 | G_HYPO::setFlags() -- set the flags of all the T_HYPOs in the
 |                       G_HYPO
 *-------------------------------------------------------------------*/

void G_HYPO::setFlags()
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    (*tHypoPtr).setFlag();
  }
}

/*-------------------------------------------------------------------*
 | G_HYPO::resetFlags() -- reset the flags of all the T_HYPOs in the
 |                         G_HYPO
 *-------------------------------------------------------------------*/

void G_HYPO::resetFlags()
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    (*tHypoPtr).resetFlag();
  }
}

/*-------------------------------------------------------------------*
 | G_HYPO::allFlagsAreSet() -- see if the T_HYPOs in this G_HYPO have
 |                             all had their flags set
 *-------------------------------------------------------------------*/

int G_HYPO::allFlagsAreSet()
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    if( ! (*tHypoPtr).flagIsSet() )
      return 0;
  }

  return 1;
}

/*-------------------------------------------------------------------*
 | G_HYPO::describe() -- diagnostics
 *-------------------------------------------------------------------*/

void G_HYPO::describe( int spaces )
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  int k;

  Indent( spaces ); cout << "G_HYPO "; print(); cout << endl;

  Indent( spaces ); cout << "|";
  cout << " numTHyposUsed = " << m_numTHyposUsedInProblem;
  cout << ", logLikelihood = " << m_logLikelihood;
  cout << endl;

  Indent( spaces ); cout << "| tHypo's:";
  k = 0;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    if( k++ >= 3 )
    {
      cout << endl;
      Indent( spaces ); cout << "|         ";
      k = 0;
    }

    cout << " "; (*tHypoPtr).print();
  }
  cout << endl;
}

mht_report.c -----------------------------------------------------------------------

/*********************************************************************
 * FILE: mht_report.C                                                *
 *                                                                   *
 * AUTHOR: Matthew Miller (mlm)                                      *
 *                                                                   *
 * HISTORY:                                                          *
 *   13 AUG 93 -- (mlm) commented                                    *
 *                                                                   *
 * CONTENTS:                                                         *
 *                                                                   *
 *   Member functions for REPORT objects.  See mht.H.                *
 *                                                                   *
 * ----------------------------------------------------------------- *
 *                                                                   *
 *             Copyright (c) 1993, NEC Research Institute            *
 *                       All Rights Reserved.                        *
 *                                                                   *
 *   Permission to use, copy, and modify this software and its       *
 *   documentation is hereby granted only under the following terms  *
 *   and conditions.  Both the above copyright notice and this       *
 *   permission notice must appear in all copies of the software,    *
 *   derivative works or modified versions, and any portions         *
 *   thereof, and both notices must appear in supporting             *
 *   documentation.                                                  *
 *                                                                   *
 *   Correspondence should be directed to NEC at:                    *
 *                                                                   *
 *                     Ingemar J. Cox                                *
 *                                                                   *
 *                     NEC Research Institute                        *
 *                     4 Independence Way                            *
 *                     Princeton                                     *
 *                     NJ 08540                                      *
 *                                                                   *
 *                     phone:  609 951 2722                          *
 *                     fax:  609 951 2482                            *
 *                     email:  ingemar@research.nj.nec.com (Inet)    *
 *                                                                   *
 *                                                                   *
 *********************************************************************/

#include "mht.h"

/*-------------------------------------------------------------------*
 | REPORT::setAllGroupIds() -- set the group id's of all the track
 |                             trees that use this REPORT
 |
 | This loops through each T_HYPO that is linked to the REPORT and
 | gets the track tree that it's on.  It then looks at the group id
 | of the tree.  If the group id has not yet been set, it simply sets
 | it.  If it has already been set to a different id, then that means
 | that the tree also contains a T_HYPO linked to another REPORT, and
 | all the trees linked to that REPORT have to be in the same group
 | as the trees linked to this REPORT.  So we search back in the list
 | of REPORTs, looking for those that have the tree's current group
 | id, and call setAllGroupIds() on them, recursively.
 *-------------------------------------------------------------------*/

void REPORT::setAllGroupIds( int groupId )
{
  BGN

  PTR_INTO_iDLIST_OF< REPORT > reportPtr;
  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  T_TREE *tree;
  int treeGroupId;

  m_groupId = groupId;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    tree = (*tHypoPtr).getTree();
    treeGroupId = tree->getGroupId();

    if( treeGroupId != groupId )
    {
      tree->setGroupId( groupId );
      if( treeGroupId != -1 )
      {
        for( (reportPtr = this),--reportPtr; reportPtr.isValid(); --reportPtr )
          if( (*reportPtr).m_groupId == treeGroupId )
            (*reportPtr).setAllGroupIds( groupId );
      }
    }
  }
}

/*-------------------------------------------------------------------*
 | REPORT::checkGroupIds() -- diagnostic
 *-------------------------------------------------------------------*/

void REPORT::checkGroupIds()
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  T_TREE *tree;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    tree = (*tHypoPtr).getTree();

    if( tree->getGroupId() != m_groupId )
      THROW_ERR( "Bad group id for report" )
  }
}

/*-------------------------------------------------------------------*
 | REPORT::describe() -- diagnostic
 *-------------------------------------------------------------------*/

void REPORT::describe( int spaces )
{
  BGN

  PTR_INTO_LINKS_TO< T_HYPO > tHypoPtr;
  int k;

  Indent( spaces ); cout << "REPORT "; print(); cout << endl;

  Indent( spaces ); cout << "| tHypo's:";
  k = 0;

  LOOP_LINKS( tHypoPtr, m_tHypoLinks )
  {
    if( k++ >= 3 )
    {
      cout << endl;
      Indent( spaces ); cout << "|         ";
      k = 0;
    }

    cout << " "; (*tHypoPtr).print();
  }
  cout << endl;
}

mht_track.c ------------------------------------------------------------------------

/*********************************************************************
 * FILE: mht_track.C                                                 *
 *                                                                   *
 * AUTHOR: Matthew Miller (mlm)                                      *
 *                                                                   *
 * HISTORY:                                                          *
 *   13 AUG 93 -- (mlm) commented                                    *
 *                                                                   *
 * CONTENTS:                                                         *
 *                                                                   *
 *   Member functions for T_TREE and T_HYPO objects.  See mht.H.     *
 *                                                                   *
 * ----------------------------------------------------------------- *
 *                                                                   *
 *             Copyright (c) 1993, NEC Research Institute            *
 *                       All Rights Reserved.                        *
 *                                                                   *
 *   Permission to use, copy, and modify this software and its       *
 *   documentation is hereby granted only under the following terms  *
 *   and conditions.  Both the above copyright notice and this       *
 *   permission notice must appear in all copies of the software,    *
 *   derivative works or modified versions, and any portions         *
 *   thereof, and both notices must appear in supporting             *
 *   documentation.                                                  *
 *                                                                   *
 *   Correspondence should be directed to NEC at:                    *
 *                                                                   *
 *                     Ingemar J. Cox                                *
 *                                                                   *
 *                     NEC Research Institute                        *
 *                     4 Independence Way                            *
 *                     Princeton                                     *
 *                     NJ 08540                                      *
 *                                                                   *
 *                     phone:  609 951 2722                          *
 *                     fax:  609 951 2482                            *
 *                     email:  ingemar@research.nj.nec.com (Inet)    *
 *                                                                   *
 *********************************************************************/

#include "mht.h"

/*-------------------------------------------------------------------*
 | T_HYPO::describe() -- diagnostic
 *-------------------------------------------------------------------*/

void T_HYPO::describe( int spaces, int depth )
{
  BGN

  PTR_INTO_LINKS_TO< G_HYPO > gHypoPtr;
  int i, k;

  Indent( spaces - 1);
  for( i = 0; i < depth; i++ )
    cout << " |";
  cout << " **T_HYPO "; print(); cout << endl;

  Indent( spaces - 1 );
  for( i = 0; i <= depth; i++ )
    cout << " |";
  cout << "   track = " << getTrackStamp();
  cout << ", time = " << m_timeStamp;
  cout << ", group id = " << getGroupId();
  cout << endl;

  Indent( spaces - 1 );
  for( i = 0; i <= depth; i++ )
    cout << " |";
  if( m_reportLink.isEmpty() )
    cout << "   NO REPORT";
  else
  {
    cout << "   report = "; (*m_reportLink).print();
  }
  cout << ", logLikelihood = " << m_logLikelihood;
  if( ! m_mustVerify )
    cout << ", NEED NOT VERIFY";
  if( m_endsTrack )
    cout << ", ENDS TRACK";
  cout << endl;

  Indent( spaces - 1 );
  for( i = 0; i <= depth; i++ )
    cout << " |";
  cout << "   gHypo's:";
  k = 0;

  LOOP_LINKS( gHypoPtr, m_gHypoLinks )
  {
    if( k++ >= 3 )
    {
      cout << endl;
      Indent( spaces - 1 );
      for( i = 0; i <= depth; i++ )
        cout << " |";
      cout << "           ";
      k = 0;
    }

    cout << " "; (*gHypoPtr).print();
  }
  cout << endl;
}

/*-------------------------------------------------------------------*
 | T_HYPO::describeTree() -- recursive diagnostic
 *-------------------------------------------------------------------*/

void T_HYPO::describeTree( int spaces, int depth )
{
  BGN

  PTR_INTO_iTREE_OF< T_HYPO > childPtr;

  describe( spaces, depth );

  LOOP_TREEchildren( childPtr, this )
  {
    (*childPtr).describeTree( spaces, depth + 1 );
  }
}

END OF FILES -----------------------------------------------------------------------
.


